"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Graphviz = exports.GraphvizRenderingOutput = exports.GraphvizRenderingProps = void 0;
const fs = __importStar(require("fs"));
const util = __importStar(require("util"));
const hasbin = __importStar(require("hasbin"));
const ts_graphviz_1 = require("ts-graphviz");
const child_process_1 = __importDefault(require("child_process"));
const chalk_1 = __importDefault(require("chalk"));
const terminal_link_1 = __importDefault(require("terminal-link"));
const sanitizeFilename = require('sanitize-filename');
const exec = util.promisify(child_process_1.default.exec);
const diagram_renderer_1 = require("../diagram-renderer");
const GraphvizGenerator_1 = require("./GraphvizGenerator");
const path = __importStar(require("path"));
class GraphvizRenderingProps extends diagram_renderer_1.RenderingProps {
}
exports.GraphvizRenderingProps = GraphvizRenderingProps;
class GraphvizRenderingOutput {
    constructor(imagePath, imageType) {
        this.imagePath = imagePath;
        this.imageType = imageType;
    }
    userOutput() {
        if (terminal_link_1.default.isSupported)
            console.log(chalk_1.default.green(`CDK code diagram generated to ${this.imageType.toUpperCase()} at ${chalk_1.default.bold((0, terminal_link_1.default)(this.imagePath, this.imagePath))}`));
        else
            console.log(chalk_1.default.green(`CDK code diagram generated to ${this.imageType.toUpperCase()} at ${chalk_1.default.bold(this.imagePath)}`));
    }
}
exports.GraphvizRenderingOutput = GraphvizRenderingOutput;
class Graphviz {
    async render(props) {
        const basePath = props.path.replace(/\.[^/.]+$/, "");
        const targetDotPath = `${basePath}.dot`;
        const targetPngPath = `${basePath}.png`;
        this.renderToDot(props.diagram, targetDotPath);
        await Graphviz.generatePng(targetDotPath, targetPngPath);
        return new GraphvizRenderingOutput(targetPngPath, "png");
    }
    renderToDot(dia, targetDotPath) {
        const graphRoot = new GraphvizGenerator_1.GraphvizGenerator().generate(dia);
        const dot = (0, ts_graphviz_1.toDot)(graphRoot);
        fs.writeFileSync(targetDotPath, dot);
    }
    static async generatePng(dotPath, targetPngPath) {
        try {
            await Graphviz.dotToPng(dotPath, targetPngPath);
        }
        catch (e) {
            if (!hasbin.sync(Graphviz.GRAPHVIZ_BINARY)) {
                throw new diagram_renderer_1.RenderingError("Graphvig '" + Graphviz.GRAPHVIZ_BINARY + "' binary does not exist locally or in PATH", [], [
                    "Install Graphviz and make sure it is available in PATH",
                    "Using brew: 'brew install graphviz'"
                ]);
            }
            else {
                if (e instanceof diagram_renderer_1.RenderingError) {
                    throw e;
                }
                else {
                    throw new diagram_renderer_1.RenderingError(e.message);
                }
            }
        }
    }
    static sanitizeAndResolvePath(dirty) {
        return path.resolve(dirty.split(path.sep).map(it => {
            return sanitizeFilename(it);
        }).join(path.sep));
    }
    static async dotToPng(sourceDotFile, targetPngFile) {
        const cmdParts = [
            Graphviz.GRAPHVIZ_BINARY,
            Graphviz.sanitizeAndResolvePath(sourceDotFile),
            `-T png`,
            `>`,
            Graphviz.sanitizeAndResolvePath(targetPngFile)
        ];
        const { stdout, stderr } = await exec(cmdParts.join(" "));
        const fileExists = fs.existsSync(targetPngFile);
        if (!fileExists) {
            throw new diagram_renderer_1.RenderingError("Failed to generate PNG: file does not exist.");
        }
        const stats = fs.lstatSync(targetPngFile);
        if (stats.size < 2) {
            throw new diagram_renderer_1.RenderingError("Generated PNG doesn't seem valid: file size is too small.", [stdout, stderr], [". make sure Graphviz is installed and available in the PATH"]);
        }
    }
}
exports.Graphviz = Graphviz;
Graphviz.GRAPHVIZ_BINARY = "dot";
//# sourceMappingURL=graphviz.js.map