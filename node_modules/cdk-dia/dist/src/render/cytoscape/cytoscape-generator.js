"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CytoscapeGenerator = void 0;
const _ = __importStar(require("lodash"));
const styling_1 = require("../styling");
class CytoscapeGenerator {
    static generate(dia) {
        const elements = this.elements(dia);
        const styles = CytoscapeGenerator.styles();
        return [elements, styles];
    }
    static styles() {
        const styles = [
            {
                selector: 'node',
                style: {
                    'label': 'data(id)',
                    'border-style': 'solid',
                    'border-width': '1px',
                    'border-color': 'green',
                }
            },
            {
                selector: 'edge',
                style: {
                    "width": 2,
                    "line-color": "#D58714",
                    "target-arrow-color": "#D58714",
                    "target-arrow-shape": "circle",
                    "curve-style": "taxi",
                    "taxi-direction": "auto",
                    "taxi-turn": 50,
                    "taxi-turn-min-distance": 5
                }
            }
        ];
        for (let depth = 0; depth < 16; depth++) {
            styles.push({
                selector: `node.depth${depth}`,
                style: {
                    'background-color': styling_1.ColorPalette.byInd(depth)
                }
            });
        }
        return styles;
    }
    static elements(diagram) {
        const nodes = this.generateNodes(diagram.root);
        const edges = this.addEdges(diagram.root);
        return [...nodes, ...edges];
    }
    static generateNodes(node, parentId = undefined) {
        const data = {
            id: node.id
        };
        if (parentId)
            data.parent = parentId;
        const style = {
            'shape': 'rectangle',
            'label': node.label
        };
        if (node.subComponents().length > 0) {
            const nodeElement = {
                data, style, classes: 'depth' + node.depth()
            };
            const subComponentsNodeElements = _.flatten(node.subComponents().map(sub => this.generateNodes(sub, node.id)));
            return [nodeElement, ...subComponentsNodeElements];
        }
        else {
            style.width = '100px';
            style.height = '100px';
            if (node.icon != null && node.icon.path != null) {
                let cleanedIconPath = node.icon.path;
                const iconsCleaningRe = /\/icons\/(.*)/;
                const matches = node.icon.path.match(iconsCleaningRe);
                if (matches) {
                    cleanedIconPath = `icons/${matches[1]}`;
                }
                else {
                    cleanedIconPath = `../${cleanedIconPath}`;
                }
                style['background-fit'] = 'cover';
                style['background-image'] = cleanedIconPath;
            }
            const nodeElement = {
                data, style, classes: 'depth' + node.depth()
            };
            return [nodeElement];
        }
    }
    static addEdges(node) {
        const linkedComponentEdges = node.links.getLinkedComponents().map(edgeNode => {
            return {
                data: {
                    source: node.id,
                    target: edgeNode.id
                }
            };
        });
        const subComponentEdges = node.subComponents().map(sub => {
            return this.addEdges(sub);
        });
        return [...linkedComponentEdges, ..._.flatten(subComponentEdges)];
    }
}
exports.CytoscapeGenerator = CytoscapeGenerator;
//# sourceMappingURL=cytoscape-generator.js.map